<!DOCTYPE html />
<html>
<head>
    <title>BSP web viewer</title>
    <link rel="stylesheet" type="text/css" href="base.css" />
</head>
<body>
    <div style="width: 300px; float: left; margin: 20px 20px 0px 0px; padding: 5px; position: absolute;">
        <h1>nfs_longjump.bsp</h1>
        <p>fps: <span id="fps" /></p>
    </div>
    <div id="viewer"></div>

    <script src="jquery.min.js"></script>
    <script src="three.min.js"></script>
    <script src="FirstPersonControls.js"></script>
    <script lang="javascript">
        var camera, scene, renderer, geometry, material, mesh;
        var controls;
        var texture;
        var pointLight;

        var clock = new THREE.Clock();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            //scene.fog = new THREE.Fog(0xc0c0c0, 800, 2000);

            var ambient = new THREE.AmbientLight(0xaaaaaa);
            scene.add(ambient);

            pointLight = new THREE.PointLight(0xff0040, 1, 50);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 1000;
            camera.position.y = 100;
            scene.add(camera);

            controls = new THREE.FirstPersonControls(camera);

            controls.lookSpeed = 0.2;
            controls.movementSpeed = 500;
            controls.noFly = false;
            controls.lookVertical = true;
            controls.verticalMin = 1.5;
            controls.verticalMax = 2.0;

            controls.lon = -110;

            load_map("http://localhost/webkz/nfs_longjump.json");

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);

            $("#viewer").append(renderer.domElement);
            //document.body.appendChild(renderer.domElement);

            // Report the fps only every second, to only lightly affect measurements
            var fpsOut = document.getElementById('fps');
            setInterval(function () {
                fpsOut.innerHTML = (1000 / frameTime).toFixed(1);
            }, 1000);
        }

        function load_map(path) {
            $.ajax({
                url: path,
                error: function (jqXHR, textStatus, errorThrown) {
                    alert(textStatus);
                },
                success: function (data) {
                    add_map_to_scene(data);
                }
            });
        }

        var map_mesh, map_geometry;
        var map_material;

        var k = 100;

        function addNormalLine(vertex, normal) {
            // lines for geometry2
            lineGeometry = new THREE.Geometry();
            lineGeometry.vertices.push(new THREE.Vector3(vertex[0], vertex[1], vertex[2]));
            lineGeometry.vertices.push(new THREE.Vector3(
                vertex[0] + normal[0] * k,
                vertex[1] + normal[1] * k,
                vertex[2] + normal[2] * k
                ));
            line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
            scene.add(line);
        }

        var defaultTexture;
        loadDefaultTexture();
        function loadDefaultTexture() {
            defaultTexture = THREE.ImageUtils.loadTexture('dirt.jpg');
            defaultTexture.wrapS = THREE.RepeatWrapping;
            defaultTexture.wrapT = THREE.RepeatWrapping;
        }

        function TextureHolder(name) {
            this.name = name;
            this.glTexture = new THREE.ImageUtils.loadTexture(name);
            this.loaded = false;
            this.failed = false;
            this.glTexture.wrapS = THREE.RepeatWrapping;
            this.glTexture.wrapT = THREE.RepeatWrapping;

            var that = this;
            this.glTexture.image.onload = function () {
                console.log("loaded texture " + that.name);
                that.loaded = true;
            };

            this.glTexture.image.onerror = function () {
                console.log("could not load " + that.name);
                that.loaded = true;
                that.failed = true;
            };
        }

        // keep all textures here
        var textures = [];
        var meshes = [];

        function Mesh(texname) {
            this.texname = texname;
            this.geometry = new THREE.Geometry();
            this.geometry.faceVertexUvs = [[]];
        }

        Mesh.prototype.waitForTexture = function () {
            this.geometry.computeVertexNormals();
            this.geometry.computeBoundingSphere();

            var texture = defaultTexture;
            if (!textures.hasOwnProperty(this.texname)) {
                console.log("There is no such texture as " + this.texname);
                that.setDefaultMaterial();
                that.createMesh();
                scene.add(that.mesh);
            }
            else if (textures[this.texname].loaded) {
                if (textures[this.texname].failed) {
                    console.log("Texture named '" + this.texname + "' could not be loaded, switching to default");
                    that.setDefaultMaterial();
                    that.createMesh();
                    scene.add(that.mesh);
                } else {
                    console.log("texture named '" + this.texname + "' loaded");
                    that.setMaterial(textures[that.texname].glTexture);
                    that.createMesh();
                    scene.add(that.mesh);
                }
            }
            else {
                console.log("binding events for " + this.texname);
                var that = this;
                textures[this.texname].glTexture.image.onload = function () {
                    console.log("texture " + that.texname + " loaded");
                    that.setMaterial(textures[that.texname].glTexture);
                    that.createMesh();
                    scene.add(that.mesh);
                }
                textures[this.texname].glTexture.image.onerror = function () {
                    console.log("texture " + that.texname + " failed to load");
                    that.setDefaultMaterial();
                    that.createMesh();
                    scene.add(that.mesh);
                }
            }
        }

        Mesh.prototype.setDefaultMaterial = function () {
            this.material = new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: false, map: defaultTexture });
        }
        Mesh.prototype.setMaterial = function (texture) {
            this.material = new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: false, map: texture });
        }
        Mesh.prototype.createMesh = function (texture) {
            this.mesh = new THREE.Mesh(this.geometry, this.material);
        }

        function add_map_to_scene(map) {
            textures = [];
            meshes = [];
            vertex_assoc = [];

            // go through each face
            for (var i in map.faces) {
                var face = map.faces[i];

                var mesh;
                if (meshes.hasOwnProperty(face.texture)) {
                    mesh = meshes[face.texture];
                }
                else {
                    meshes[face.texture] = (mesh = new Mesh(face.texture));
                    textures[face.texture] = new TextureHolder("textures/" + face.texture + ".jpg");
                    vertex_assoc[face.texture] = [];
                }

                var vertices = vertex_assoc[face.texture];
                var faceVertices = [];
                for (var j in face.vertices) {
                    var vi = face.vertices[j];
                    if (!vertices.hasOwnProperty(vi)) {
                        // add vertex to geometry and map
                        mesh.geometry.vertices.push(new THREE.Vector3(map.vertices[vi][0], map.vertices[vi][2], map.vertices[vi][1]));
                        vertices[vi] = mesh.geometry.vertices.length - 1;
                    }

                    faceVertices.push(vertices[vi]);
                }

                mesh.geometry.faces.push(new THREE.Face3(faceVertices[0], faceVertices[1], faceVertices[2]));
                mesh.geometry.faceVertexUvs[0].push([
                        new THREE.UV(face.faceUVs[0], face.faceUVs[1]),
                        new THREE.UV(face.faceUVs[2], face.faceUVs[3]),
                        new THREE.UV(face.faceUVs[4], face.faceUVs[5])
                ]);
            }

            for (var i in meshes) {
                meshes[i].waitForTexture();
            }
        }

        function add_map_to_scene2(map) {
            map_geometry = new THREE.Geometry();

            for (var i = 0; i < map.vertices.length; i++) {
                var vertex = map.vertices[i];
                var x = vertex[0];
                var y = vertex[2];
                var z = vertex[1];
                map_geometry.vertices.push(new THREE.Vector3(x, y, z));
            }

            map_geometry.faceVertexUvs = [[]];

            for (var i = 0; i < map.faces.length; ++i) {
                var face = map.faces[i];
                map_geometry.faces.push(new THREE.Face3(face.vertices[0], face.vertices[1], face.vertices[2]));
                map_geometry.faceVertexUvs[0].push([
                    new THREE.UV(face.faceUVs[0], face.faceUVs[1]),
                    new THREE.UV(face.faceUVs[2], face.faceUVs[3]),
                    new THREE.UV(face.faceUVs[4], face.faceUVs[5])
                ]);

                if (false) {
                    addNormalLine([
                        map.vertices[face.vertices[0] * 3],
                        map.vertices[face.vertices[0] * 3 + 2],
                        map.vertices[face.vertices[0] * 3 + 1]], face.normal);

                    addNormalLine([
                        map.vertices[face.vertices[1] * 3],
                        map.vertices[face.vertices[1] * 3 + 2],
                        map.vertices[face.vertices[1] * 3 + 1]], face.normal);

                    addNormalLine([
                        map.vertices[face.vertices[2] * 3],
                        map.vertices[face.vertices[2] * 3 + 2],
                        map.vertices[face.vertices[2] * 3 + 1]], face.normal);
                }
            }

            map_geometry.computeVertexNormals();
            map_geometry.computeBoundingSphere();

            map_material = new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: false, map: defaultTexture });
            map_mesh = new THREE.Mesh(map_geometry, map_material);

            scene.add(map_mesh);
            console.log("level loaded successfully");
        }

        // http://stackoverflow.com/questions/4787431/check-fps-in-js
        // The higher this value, the less the fps will reflect temporary variations
        // A value of 1 will only keep the last value
        var filterStrength = 40;
        var frameTime = 0, lastLoop = new Date, thisLoop;

        function animate() {
            var thisFrameTime = (thisLoop = new Date) - lastLoop;
            frameTime += (thisFrameTime - frameTime) / filterStrength;
            lastLoop = thisLoop;

            // note: three.js includes requestAnimationFrame shim
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            var delta = clock.getDelta();
            controls.update(delta);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
